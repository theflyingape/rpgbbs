/*
 *  Source machine generated by GadToolsBox V2.0
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Robert Hurst
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include "license.h"

char __near *__procname="RPGBBSlicense";
long __near __stack=4096;
long __near __priority=0;

static struct Screen         *Scr = NULL;
static UBYTE                 *PubScreenName = NULL;
static APTR                   VisualInfo = NULL;
struct Window         *MainWnd = NULL;
static struct Gadget         *MainGList = NULL;
struct IntuiMessage    MainMsg;
struct Gadget         *MainGadgets[9];
static UWORD                  MainLeft = 0;
static UWORD                  MainTop = 11;
static UWORD                  MainWidth = 322;
static UWORD                  MainHeight = 140;
static UBYTE                 *MainWdt = (UBYTE *)"RPGBBS Licenses";
static struct TextAttr       *Font, Attr;
static UWORD                  FontX, FontY;
static UWORD                  OffX, OffY;

static UWORD MainGTypes[] = {
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	LISTVIEW_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	TEXT_KIND
};

static struct NewGadget MainNGad[] = {
	0, 0, 61, 19, (UBYTE *)"New", NULL, GD_New, PLACETEXT_IN, NULL, (APTR)NewClicked,
	0, 20, 61, 19, (UBYTE *)"Delete", NULL, GD_Delete, PLACETEXT_IN, NULL, (APTR)DeleteClicked,
	0, 40, 61, 19, (UBYTE *)"GenKey", NULL, GD_GenKey, PLACETEXT_IN, NULL, (APTR)GenKeyClicked,
	61, 0, 261, 64, NULL, NULL, GD_License, 0, NULL, (APTR)LicenseClicked,
	61, 65, 261, 13, (UBYTE *)"Name", NULL, GD_Name, PLACETEXT_LEFT, NULL, (APTR)NameClicked,
	61, 79, 261, 13, (UBYTE *)"Addr1", NULL, GD_Addr1, PLACETEXT_LEFT, NULL, (APTR)Addr1Clicked,
	61, 93, 261, 13, (UBYTE *)"Addr2", NULL, GD_Addr2, PLACETEXT_LEFT, NULL, (APTR)Addr2Clicked,
	61, 107, 261, 13, (UBYTE *)"Addr3", NULL, GD_Addr3, PLACETEXT_LEFT, NULL, (APTR)Addr3Clicked,
	61, 126, 261, 13, (UBYTE *)"Key", NULL, GD_Key, PLACETEXT_LEFT, NULL, NULL
};

static ULONG MainGTags[] = {
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GTLV_ShowSelected), NULL, (TAG_DONE),
	(GTST_MaxChars), 30, (TAG_DONE),
	(GTST_MaxChars), 30, (TAG_DONE),
	(GTST_MaxChars), 30, (TAG_DONE),
	(GTST_MaxChars), 30, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE)
};

#define MAXKEY 5000
#define KEYNODE(n) (KEYnode+n)
#define NAME(n) (Name+30*n)
#define ADDR(i,j) (Addr+3*30*i+30*j)

struct MinList KEYlist;
struct Node *KEYnode;
UWORD MaxKey,key;
UBYTE *Name;
UBYTE *Addr;

void PackString(UBYTE *result,UBYTE *str,UBYTE size)
{
	struct radix {
		char one:6;
		char two:6;
		char three:6;
		char four:6;
	} radix;
	char b;
	int i,j;

	memset(result,0,size);
	memset(&radix,0,3);

	for(i=0,j=0; i<size; i++) {
		b=str[i];
		if(b<' ')
			b=' ';
		b-=' ';
		switch(i%4) {
			case 0:
				radix.one=b;
				break;
			case 1:
				radix.two=b;
				break;
			case 2:
				radix.three=b;
				break;
			case 3:
				radix.four=b;
				memcpy(&result[j],&radix,3);
				j+=3;
				memset(&radix,0,3);
				break;
		}
	}
	if(size%4)
		memcpy(&result[j],&radix,3);
}

UWORD CheckOne(char *str)
{
	UWORD i,result=0;

	for(i=0; i<12; i++) {
		result-=i;
		result-=(str[i]-i)*(str[23-i]-i);
	}
	return(result);
}

UWORD CheckTwo(char *str)
{
	UWORD i,result=0;

	for(i=0; i<24; i+=2) {
		result+=i;
		result+=(str[i]+i)*(str[i+1]+i);
	}

	return(result);
}

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 4 ) / 8 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int MainCloseWindow( void )
{
	FILE *fp;
	int i,j;

	if((fp=fopen("RPGBBSlicense.dat","w"))) {
		for(i=0; i<MaxKey; i++) {
			fprintf(fp,"%.30s\n",NAME(i));
			for(j=0; j<3; j++)
				fprintf(fp,"%.30s\n",ADDR(i,j));
		}
		fclose(fp);
	}
	return('Q');
}

int HandleMainIDCMP( void )
{
	struct IntuiMessage	*m;
	int			(*func)();
	BOOL			running = TRUE;

	while( m = GT_GetIMsg( MainWnd->UserPort )) {

		CopyMem(( char * )m, ( char * )&MainMsg, (long)sizeof( struct IntuiMessage ));

		GT_ReplyIMsg( m );

		switch ( MainMsg.Class ) {

			case	IDCMP_CLOSEWINDOW:
				running = MainCloseWindow();
				break;

			case	IDCMP_GADGETUP:
			case	IDCMP_GADGETDOWN:
				func = ( void * )(( struct Gadget * )MainMsg.IAddress )->UserData;
				running = func();
				break;
		}
	}
	return( running );
}

int OpenMainWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft, wtop, ww, wh;

	ComputeFont( MainWidth, MainHeight );

	ww = ComputeX( MainWidth );
	wh = ComputeY( MainHeight );

	wleft=(Scr->Width-ww)/2;
	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	wtop=(Scr->Height-wh)/2;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &MainGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Main_CNT; lc++ ) {

		CopyMem((char * )&MainNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		MainGadgets[ lc ] = g = CreateGadgetA((ULONG)MainGTypes[ lc ], g, &ng, ( struct TagItem * )&MainGTags[ tc ] );

		while( MainGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( MainWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	BUTTONIDCMP|LISTVIEWIDCMP|STRINGIDCMP|IDCMP_CLOSEWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	MainGList,
				WA_Title,	MainWdt,
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( MainWnd, NULL );

	return( 0L );
}

void CloseMainWindow( void )
{
	if ( MainWnd        ) {
		CloseWindow( MainWnd );
		MainWnd = NULL;
	}

	if ( MainGList      ) {
		FreeGadgets( MainGList );
		MainGList = NULL;
	}
}

void RefreshLicense(void)
{
	int i,j,k;

	GT_SetGadgetAttrs(MainGadgets[GD_License],MainWnd,NULL,
		(GTLV_Labels),(ULONG)~0,
		(TAG_DONE));
	for(i=0; i<MaxKey; i++)
		for(j=i; j>0 && strncmp(NAME(j),NAME((j-1)),30)<0; j--) {
			swmem(NAME(j),NAME((j-1)),30);
			for(k=0; k<3; k++)
				swmem(ADDR(j,k),ADDR((j-1),k),30);
			key+=(key==j) ? -1 : (key==j-1) ? +1 : 0;
		}
	KEYlist.mlh_Head=NULL;
	KEYlist.mlh_Tail=NULL;
	KEYlist.mlh_TailPred=NULL;
	for(i=0; i<MaxKey; i++) {
		KEYNODE(i)->ln_Succ=(struct Node *)&KEYlist.mlh_Tail;
		if(i) {
			KEYNODE(i-1)->ln_Succ=KEYNODE(i);
			KEYNODE(i)->ln_Pred=KEYNODE(i-1);
		}
		else {
			KEYNODE(i)->ln_Pred=(struct Node *)&KEYlist.mlh_Head;
			KEYlist.mlh_Head=(struct MinNode *)KEYNODE(0);
		}
		KEYNODE(i)->ln_Type=0;
		KEYNODE(i)->ln_Pri=0;
		KEYNODE(i)->ln_Name=NAME(i);
		KEYlist.mlh_TailPred=(struct MinNode *)KEYNODE(i);
	}
	GT_SetGadgetAttrs(MainGadgets[GD_License],MainWnd,NULL,
		(GTLV_Labels),(ULONG)&KEYlist,
		(GTLV_Top),(ULONG)key,
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Name],MainWnd,NULL,
		(GTST_String),(ULONG)NAME(key),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr1],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,0),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr2],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,1),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr3],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,2),
		(TAG_DONE));
	ActivateGadget(MainGadgets[GD_Name],MainWnd,NULL);
}

int NewClicked( void )
{
	if(MaxKey<MAXKEY) {
		key=MaxKey++;
		strcpy(NAME(key),"NEW ENTRY");
	}
	RefreshLicense();
	return(FALSE);
}

int DeleteClicked( void )
{
	int i,j;

	if(MaxKey) {
		MaxKey--;
		for(i=key; i<MaxKey; i++) {
			strncpy(NAME(i),NAME((i+1)),30);
			for(j=0; j<3; j++)
				strncpy(ADDR(i,j),ADDR((i+1),j),30);
		}
		memset(NAME(MaxKey),0,30);
		for(j=0; j<3; j++)
			memset(ADDR(MaxKey,j),0,30);
		if(key>0 && key==MaxKey)
			key--;
		RefreshLicense();
	}
	return(FALSE);
}

int LicenseClicked( void )
{
	key=MainMsg.Code;
	GT_SetGadgetAttrs(MainGadgets[GD_Name],MainWnd,NULL,
		(GTST_String),(ULONG)NAME(key),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr1],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,0),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr2],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,1),
		(TAG_DONE));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr3],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,2),
		(TAG_DONE));
	return(FALSE);
}

int GenKeyClicked( void )
{
	FILE *LICfp,*PXLfp;
	int i,size;
	UWORD checksum[4];
	UBYTE text[30];
	UBYTE result[4][24];
	char *s;

	if((LICfp=fopen("RAM:RPGBBS.license","wb"))) {
		if((PXLfp=fopen("RPGBBSlicense.logo","rb"))) {
			fseek(PXLfp,0,SEEK_END);
			size=ftell(PXLfp);
			if((s=malloc(size))) {
				fseek(PXLfp,0,SEEK_SET);
				fread(s,size,1,PXLfp);
				fwrite(s,size,1,LICfp);
				fwrite("\15",1,1,LICfp);
				PackString(result[0],NAME(key),30);
				for(i=0; i<3; i++)
					PackString(result[i+1],ADDR(key,i),30);
				for(i=0; i<4; i++)
					fwrite(result[i],sizeof(result[i]),1,LICfp);
				checksum[0]=CheckOne(result[0]);
				checksum[1]=CheckTwo(result[1]);
				checksum[2]=CheckOne(result[2]);
				checksum[3]=CheckTwo(result[3]);
				fwrite(&checksum,sizeof(checksum),1,LICfp);
				free(s);
			}
			fclose(PXLfp);
		}
		fclose(LICfp);
		sprintf(text,"%X-%X-%X-%X",checksum[0],checksum[1],checksum[2],checksum[3]);
		GT_SetGadgetAttrs(MainGadgets[GD_Key],MainWnd,NULL,
			(GTTX_Text),(ULONG)text,
			(TAG_DONE));
	}
	return(FALSE);
}

int NameClicked( void )
{
	if(strnicmp(NAME(key),GetString(MainGadgets[GD_Name]),30)) {
		strncpy(NAME(key),GetString(MainGadgets[GD_Name]),30);
		strupr(NAME(key));
		RefreshLicense();
	}
	return(FALSE);
}

int Addr1Clicked( void )
{
	strncpy(ADDR(key,0),GetString(MainGadgets[GD_Addr1]),30);
	strupr(ADDR(key,0));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr1],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,0),
		(TAG_DONE));
	return(FALSE);
}

int Addr2Clicked( void )
{
	strncpy(ADDR(key,1),GetString(MainGadgets[GD_Addr2]),30);
	strupr(ADDR(key,1));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr2],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,1),
		(TAG_DONE));
	return(FALSE);
}

int Addr3Clicked( void )
{
	strncpy(ADDR(key,2),GetString(MainGadgets[GD_Addr3]),30);
	strupr(ADDR(key,2));
	GT_SetGadgetAttrs(MainGadgets[GD_Addr3],MainWnd,NULL,
		(GTST_String),(ULONG)ADDR(key,2),
		(TAG_DONE));
	return(FALSE);
}

void main(void)
{
	FILE *fp;
	int i,j,exit;

	KEYnode=(struct Node *)calloc(MAXKEY,sizeof(KEYnode));
	Name=calloc(MAXKEY,30);
	Addr=calloc(MAXKEY,3*30);

	MaxKey=0;
	key=0;
	if((fp=fopen("RPGBBSlicense.dat","r"))) {
		while(!feof(fp)) {
			fgets(NAME(MaxKey),30,fp);
			if((i=strlen(NAME(MaxKey))))
				*(NAME(MaxKey)+i-1)=NULL;
			if(strlen(NAME(MaxKey))) {
				for(j=0; j<3; j++) {
					fgets(ADDR(MaxKey,j),30,fp);
					if((i=strlen(ADDR(MaxKey,j))))
						*(ADDR(MaxKey,j)+i-1)=NULL;
				}
				MaxKey++;
			}
		}
		fclose(fp);
	}

	SetupScreen();
	OpenMainWindow();
	RefreshLicense();
	do {
		Wait(1L<<MainWnd->UserPort->mp_SigBit);
		exit=HandleMainIDCMP();
	} while(exit!='Q');
	CloseMainWindow();
	CloseDownScreen();

	free(Addr);
	free(Name);
	free(KEYnode);
}
